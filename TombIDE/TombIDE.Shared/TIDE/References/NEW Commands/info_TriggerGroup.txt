Syntax: TriggerGroup= IdGroup, ExportValue1 + TGROUP_ flags, ExportValue2, ExportValue3, {Other Values 1/2/3 of exported triggers or conditions)
Scope: To use in [Level] section
Max number of instances for level section: 999

TriggerGroup permits to host two or more triggers to perform them in same moment using a single flipeffect "Perform TriggerGroup..".
You can also perform a TriggerGroup using a condition trigger "Check condition of <&>TriggerGroup" and in this case the condition will be true if all conditions typed in TriggerGroup command will be true.

You can get the data to type in TriggerGroup comand, from Trigger Window of NGLE program, clicking on button named "Export Script Trigger". If you don't see any button with that name, this means that specific trigger can't be exported in script format.
You can export following triggers:

Flipeffects
Actions
Conditions

When you export a trigger as script trigger you'll get a text file containing informations like these:

---- Begin file ---------

Add following three values in your script command:

... , $2000, 96, $0

Infos about exported trigger
--------------------------------------
Type: FLIPEFFECT
<#> : Lara. Disarm Lara in <&>way
<&> : Remove All. (Weapons + Ammos)
(E) : 
--------------------------------------

--- End file ----

In above example the values to add to your TriggerGroup command are the values: "$2000, 96, $0"
Other informations you read in text files are given only for reference, to remember that above three numbers perform the trigger "Lara. Disarm Lara" ...

Arguments:

IdGroup
-------
The IdGroup is a simple progressive number you type to recognize this TriggerGroup from other TriggerGroup commands in same [Level] section.
You'll use the IdGroup number to start via trigger this TriggerGroup, in fact, when you in trigger window select a flipeffect "Perform <&>Trigger Group" in the "<&>" field you'll have to choose a TriggerGroup between different triggergroup with different IdGroup values.
You should start with "1" for first TriggerGroup and continue with "2" and then "3" when you add other TriggerGroup to your [Level] section.

Note: the valid range for IdGroup field is 1 / 9999

Exported Trigger values
-----------------------
After IdGroup field, you can type a list of triple values, each group of three values have been get from an "Export Script Trigger" operation.
Pratically to keep the data of a single trigger are necessary three values and you'll type these three values in same order you see in text get from "Export Script Trigger" button.

The general syntax fo TriggerGroup becomes hence:

TriggerGroup= IdGroup,  {Alfa1, Alfa2, Alfa3}, {Beta1, Beta2, Beta3}, {...}, 
{Omega1, Omega2, Omega3}

Remark: the "{" "}" parenthesis don't have to be written really, they are present in above row only to idenfity the optional group of trigger data you can add in TriggerGroup command.

In above syntax, the "alfa", "beta" or "Omega" are some specific exported triggers, and the numbers "1/2/3" are the three values get for each exported trigger.


You should not modify the values you get from exporting, but you can add to first value (like "Alfa1", "Beta1"

 or "Omega1" in above example) some TGROUP_ flags to give specific means to current trigger.

You can add following TGROUP to first value of each exported trigger:

TGROUP_AND
TGROUP_NOT
TGROUP_OR
Above flags are boolean operators, they are used only to link condition triggers.
If you don't use any boolean operator the default value is always AND, this means all condition you type in sequence should be all true in same moment to get true the final condition.
Anyway in some circustances you could wish to create more particular condition.
For example if you want create a final condition was true when "Lara is climbing" or "Lara is monkey" you'll have to use the TGROUP_OR operator in this way:

   Condition1 (For lara is climbing)
   TGROUP_OR + Condition2 (For lara is monkey)

In this way just it was true at least a single condition to get true the final condition.

The TGROUP_NOT works in a different way, it is like an "AND NOT" because is linked with previous condition (if it exists) whereby an AND but inverte the mean of current condition where it has been attached.
Pratically you'll use the NOT when you don't find in condition list of trigger window the wished condition but only the opposite. Using this opposite condition with a NOT you'll inverte the mean of that condition.

TGROUP_ELSE

You can add 
TGROUP_ELSE to conditions or common trigers.
When you add this flag to some trigger you start an "else block".
The else block will be performed ONLY if previous condition block gave negative esite.
You can use ELSE to perform two different triggers (or block of triggers) in according with a single conditional block.
For example if you want load a bonus level if lara found all secrets while you want perform the tile level (to end the adventure) if lara has not found all secrets, you can realize this using an else in this way:

   Condition (Lara found <&> secrets)
       (if true) Perform trigger (Load bonus level)
   TGROUP_ELSE + Trigger (Perform title level)

In this way if lara found all secrets will be loaded bonus level, else, the title level.

You can place none, two or more ELSE flag in your TriggerGroup, creating very comples conditions.

A way to use ELSE is to test a lot of condition and perform a different trigger for each different result of above conditions.

For example:
    Condition: "Lara found 1 secret"
         Trigger: Load Level 5
    ELSE Condition: "Lara found 2 secrets"
         Trigger: Load Level 6
    ELSE Condition: "Lara found 3 secrets"
         Trigger: Load level 7

In above example we used ELSE attached to other condition. In this way we can scan a list of conditions and perform a different trigger for each result.

The rule used by game to scan a trigger group is the following:

IF current_trigger is a condition: verify if condition is true
IF it's true verify other conditions, if there are no other conditions perform the first non condition trigger found and all following non condition trigger until end of triggergroup or upto first ELSE flag found.
IF current trigger is not a condition: perform it and all following and then stop at first else flag found.

IF current_trigger is a condition and the condition is false, skip current condition block and skip following non-condition block, continue parsing until to find an ELSE flag and start to verify conditions or perform trigger from this ELSE flag.

TGROUP_USE_FOUND_ITEM_INDEX
TGROUP_USE_OWNER_ANIM_ITEM_INDEX
TGROUP_USE_TRIGGER_ITEM_INDEX
Above TGROUP flag modify the "ITEM_INDEX", where for "item index" we mean the index of moveable used by trigger (like Action) or conditions.
By default each trigger, when you export it, has already an index but in some cirucstances we need to perform actions (triggers) on moveable we don't yet know.
For example to create a fight situation like this:

"When Lara hit an enemy the enmey will lose vitality"



we have the problem about how identify the index of enemy because could exist different enemies of that slot type in the level and we cann't know while we are typing our trigger, what enemy will meet lara for first.
To solve this problem we use above flags to specifiy the index to use for following triggers or conditions.
This methodo is possible only when there is a way to locate dynamically a moveable.
For example if we perform a condition like if "Lara collides with moveable of <&>slot", when the condition is true the engine will have discovered the index of moveable is touching lara. Now, if we attach to this condition the flag TGROUP_USE_FOUND_ITEM_INDEX the found index in current condition, will be used in following triggers or conditions, and we'll be able to perform a specific trigger over this enemy detected dynamically, for example to damage it "Remove vitaltiy to <#> enemy"
When we know to want use above flag we can type our source trigger choosing any object 
indifferently because we know that it will be used another index of object to perform that action.



The flag TGROUP_USE_OWNER_ANIM_ITEM_INDEX is more easy to understand and to use.
You should use this flag only when current TriggerGroup will be performed by an animcommand inserted in some animation of some moveable.
In this circustante the TGROUP_USE_OWNER_ANIM_ITEM_INDEX flag will force as index to use the index of moveable where you inserted this animcommand.

The TGROUP_USE_TRIGGER_ITEM_INDEX
 flag
, reset the Index of moveable, forcing it newly to its original value. 
Pratically if you in previous trigger or conditon had used a flag like TGROUP_USE_OWNER_ANIM_ITEM_INDEX  or  TGROUP_USE_FOUND_ITEM_INDEX, you can to use newly the real source indices in curent and following trigger or conditions, using this flag TGROUP_USE_TRIGGER_ITEM_INDEX.
With this flag you inform the engine to use the effective index typed originally in that trigger.

Remark: you can find other explanations and examples in Reference panel of NG Center, clicking on some TGROUP_ constant in "mnemonic costant list"




